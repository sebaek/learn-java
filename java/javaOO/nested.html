<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../mystyle.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="../../myscript.js"></script>

    <title>Java Tutorials</title>


</head>

<body>


    <div class="container">
        <div class="col-sm-4">
            <div class="side-menu-container">

                <ul>
                    <li>
                        <a href="index.html">클래스와 객체</a>
                    </li>
                    <ul>
                        <li>
                            <a href="classes.html">클래스</a>
                        </li>
                        <ul>
                            <li>
                                <a href="classdec1.html">클래스 선언</a>
                            </li>
                            <li>
                                <a href="variables.html">멤버 변수 선언</a>
                            </li>
                            <li>
                                <a href="methods.html">메소드 정의</a>
                            </li>
                            <li>
                                <a href="constructors.html">생성자</a>
                            </li>
                            <li>
                                <a href="arguments.html">메소드나 생성자에 정보 전달</a>
                            </li>
                        </ul>
                        <li>
                            <a href="objects.html">객체</a>
                        </li>
                        <ul>
                            <li>
                                <a href="objectcreation.html">객체 생성</a>
                            </li>
                            <li>
                                <a href="usingobject.html">객체 사용</a>
                            </li>
                        </ul>
                        <li>
                            <a href="more.html">More on Classes</a>
                        </li>
                        <ul>
                            <li>
                                <a href="returnvalue.html">메소드에서 값 반환하기</a>
                            </li>
                            <li>
                                <a href="thiskey.html">this 키워드 사용</a>
                            </li>
                            <li>
                                <a href="accesscontrol.html">클래스의 멤버 접근 제어</a>
                            </li>
                            <li>
                                <a href="classvars.html">클래스 멤버 이해하기</a>
                            </li>
                            <li>
                                <a href="initial.html">필드 초기화</a>
                            </li>
                            <li>
                                <a href="summaryclasses.html">클래스와 객체의 생성과 사용에 대한 요약</a>
                            </li>
                        </ul>
                        <li>
                            <a href="nested.html">중첩 클래스</a>
                        </li>
                        <ul>
                            <li>
                                <a href="innerclasses.html">내부 클래스 예제</a>
                            </li>
                            <li>
                                <a href="localclasses.html">지역 클래스</a>
                            </li>
                            <li>
                                <a href="anonymousclasses.html">무명 클래스</a>
                            </li>
                            <li>
                                <a href="lambdaexpressions.html">람다 표현식</a>
                            </li>
                            <ul>

                                <li>
                                    <a href="methodreferences.html">메소드 참조</a>
                                </li>
                            </ul>
                            <li>
                                <a href="whentouse.html">중첩 클래스, 지역 클래스, 무명 클래스, 람다 표현식을 사용할 때</a>
                            </li>
                        </ul>
                        <li>
                            <a href="enum.html">Enum Types</a>
                        </li>

                    </ul>

                </ul>
            </div>
        </div>
        <div class="col-sm-8">
            <!-- 2열 시작 -->
<h1>
중첩클래스    
</h1>
<p>
자바에선
어떤 클래스를 다른 클래스 안에서 정의 할 수 있다.
이 클래스를 <em>nested class</em>라고 하며
아래 처럼 작성한다.
</p>

<pre>
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}</pre>

<p>
    <b>Terminology : </b>
nested class는 static과 non-static으로 나뉜다.
<code>static</code>으로 선언된
nested class는 <em>static nested class</em>라고
불리고, non-static class를 <em>inner class</em>라고
부른다.
</p>
<pre>
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}</pre>

<p>
nested class는 감싸고 있는 클래스의
멤버이다. inner class 감싸고 있는 
클래스의 멤버(private으로 선언되어 있어도)에 접근할 수 있다.
static nested class는 감싸고 있는
클래스의 멤버에 접근할 수 없다.
<code>OuterClass</code>의 멤버처럼,
nested class는 <code>private</code>,
<code>public</code>, <code>protected</code>,
<em>package private</em>으로 선언될 수 있다.
(바깥 클래스는 <code>public</code>이나 
<em>package private</em>으로 선언할 수 있었다.)

</p>


<h2>
    왜 nested class를 사용하는가?
</h2>
<p>
nested class를 사용하는 주된 이유는
아래와 같다.    
</p>
<ul>
    <li><strong>한 곳에서만 사용하는 클래스를
        논리적 그룹으로 묶을 수 있는 방법이다.
     : </strong>
    만약 어떤 클래스가 다른 클래스 하나에서만
사용하게 된다면, 다른 클래스 안에 넣고 함께
사용하는 것이 논리적이다. "helper class"를
안에 넣는 것은 그 묶음을 간결하게 만든다.</li>
    <li><strong>캡슐화를 강화한다 : </strong>
클래스 B가 클래스 A의 
멤버(<code>private</code>으로 선언된)에 
접근할 필요가 있다고 가정하자.
클래스 B를 클래스 A안에 숨기면,
A의 멤버가 <code>private</code>으로
선언되어도 B가 접근할 수 있다.
그리고 B 자체도 외부로부터 숨길 수 있다.
 </li>
    <li><strong>코드의 가독성과 유지보수성을 높인다 : </strong>
어떤 클래스에 담긴 작은 클래스는
그 것을 사용하는 코드와 가까운 곳에
위치하게 된다.
</li>
</ul>

<h2>
    static nested class
</h2>
<p>
클래스 메소드와 변수처럼 static nested class는 바깥
클래스와 관련이 있다.
static 클래스 메소드처럼, static nested 클래스는
감싸고 있는 클래스의 인스턴스 변수나 메소드를 직접 참조할 수 없다.
즉 객체 참조를 통해서면 접근할 수 있다.
</p>

<p>
    <b>Note : </b>
static nested class는 바깥 클래스의 인스턴스 멤버와
상호작용하는 것이 다른 top-level 클래스와 같다.
그 결과 static nested class는 편의상
묶여있는 다른 top-level 클래스 안에 있는
top-level 클래스처럼 기능한다.

</p>

<p>
    static nested class는 감싸고 있는 클래스명을
    사용하여 접근한다.
</p>

<pre>OuterClass.StaticNestedClass</pre>
<p>
    예를 들어 static nested 클래스의 객체를
    생성하기 위해선 아래 문법을 사용한다.
</p>

<pre>
OuterClass.StaticNestedClass nestedObject =
     new OuterClass.StaticNestedClass();    
</pre>

<h2>

    Inner Class
</h2>

<p>
인스턴스 메소드와 변수처럼    
inner class는 감싸고 있는 클래스의 
객체와 관련 있고 그 객체의 메소드와
필드에 직접 접근할 수 있다.
inner class는 객체와 관련 있기 때문에
그 자신은 static 멤버를
선언할 수 없다.
</p>

<p>
inner class의 객체는 outer class의 객체
안에 존재한다. 아래 코드가 있다고 가정하자.
</p>

<pre>
class OuterClass {
    ...
    class InnerClass {
        ...
    }
}</pre>
<p>
<code>InnerClass</code>의 객체는 
<code>OuterClass</code>의 객체
안에서만 존재하고 감싸고 있는
객체의 메소드와 필드에 직접 접근 가능하다.
</p>

<p>
inner class의 객체를 만드려면, 
outer class의 객체를 먼저 만들어야 한다.
다음 outer 객체안에 inner 객체를 만들어야
한다. 아래 문법 처럼 :
</p>

<pre>OuterClass.InnerClass innerObject = outerObject.new InnerClass();</pre>

<p>
inner 클래스는 두 개의 특별한 클래스가 있다.    
: 로컬 클래스와 무명클래스이다.
</p>

<h2>
    Shadowing
</h2>

<p>
어떤 특정 scope의 변수의 선언(
    멤버 변수나 파라미터)이
그 scope을 감싸는 scope의 선언과 이름이
같다면, 그 선언은 바깥 scope의 선언을
shadow한다.
가려진 선언을 이름만으로 참조할 수 없다.
아래 <code>ShadowTest</code> 프로그램에서
예제를 보여준다.
</p>

<pre>
public class ShadowTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            System.out.println("x = " + x);
            System.out.println("this.x = " + this.x);
            System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);
        }
    }

    public static void main(String... args) {
        ShadowTest st = new ShadowTest();
        ShadowTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}</pre>
<p>
    이 프로그램의 결과는 다음과 같다.
</p>
<pre>
x = 23
this.x = 1
ShadowTest.this.x = 0</pre>

<p>
이 예제에서는 <code>x</code>라는 이름의
변수를 3개 정의한다. 
<code>ShadowTest</code>의 멤버변수와
inner class <code>FirstLevel</code>의
멤버변수와 <code>methodInFirstLevel</code>의
파라미터이다.
메소드의 파라미터로 정의된 <code>x</code>는
inner class <code>FirstLevel</code>의
변수를 가린다. 그래서
<code>methodInFirstLevel</code>에서
<code>x</code>를 사용하면 메소드 파라미터를
가리킨다. <code>FirstLevel</code>의 멤버변수를
가리키기 위해서는 <code>this</code>키워드를
사용해야 한다.
</p>

<pre>System.out.println("this.x = " + this.x);</pre>

<p>
더 큰 scope의 멤버변수를 가리키기 위해서는
변수가 속한 클래스의 이름을 사용해야 한다.
예를 들어, 아래 명령문은 <code>ShadowTest</code> 클래스의
멤버변수를 <code>methodInFirstLevel</code> 메소드에서
사용하는 코드이다.
</p>

<pre>System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);</pre>

<h2>
    Serialization
</h2>

<p>
inner class, local class, anonymouse class의
Serialization은 강력하게 권장하지 않는다.
자바 컴파일러가 
inner class 같은 어떤 구성요소들를 컴파일할 때, 
<em>synthetic constructs</em>를 만든다. 이 것은
소스코드에 있는 구성과는 다른
클래스, 메소드, 필드 등의 구성요소 이다.
Synthetic constructs는 컴파일러가 JVM의 변경없이 자바의 새로운 기능을 구현 가능하게 한다.
그러나 Syntehtic constructs는 자바 컴파일러 구현에 따라 다양해 질 수 있다.
즉, <code>.class</code>파일 역시 구현에 따라 다양해진다.
결과적으로 innser class를 serialize와 deserialize하는 것은 다른 JRE 구현에 따라
호환성 문제가 생길 수 있다. inner class가 컴파일될 때 생성되는
synthetic constructs에 대해 더 많은 정보를 얻기 위해선
<a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html">Obtaining Names of Method Parameters</a>의
<a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html#implcit_and_synthetic">Implicit and Synthetic Parameters</a>
섹션을 보라
</p>


        <!-- 2열 끝 -->
        </div>

        <!-- container 끝 -->
    </div>

</body>

</html>