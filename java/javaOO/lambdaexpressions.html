<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../mystyle.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="../../myscript.js"></script>

    <title>Java Tutorials</title>


</head>

<body>


    <div class="container">
        <div class="col-sm-4">
            <div class="side-menu-container">

                <ul>
                    <li>
                        <a href="index.html">클래스와 객체</a>
                    </li>
                    <ul>
                        <li>
                            <a href="classes.html">클래스</a>
                        </li>
                        <ul>
                            <li>
                                <a href="classdec1.html">클래스 선언</a>
                            </li>
                            <li>
                                <a href="variables.html">멤버 변수 선언</a>
                            </li>
                            <li>
                                <a href="methods.html">메소드 정의</a>
                            </li>
                            <li>
                                <a href="constructors.html">생성자</a>
                            </li>
                            <li>
                                <a href="arguments.html">메소드나 생성자에 정보 전달</a>
                            </li>
                        </ul>
                        <li>
                            <a href="objects.html">객체</a>
                        </li>
                        <ul>
                            <li>
                                <a href="objectcreation.html">객체 생성</a>
                            </li>
                            <li>
                                <a href="usingobject.html">객체 사용</a>
                            </li>
                        </ul>
                        <li>
                            <a href="more.html">More on Classes</a>
                        </li>
                        <ul>
                            <li>
                                <a href="returnvalue.html">메소드에서 값 반환하기</a>
                            </li>
                            <li>
                                <a href="thiskey.html">this 키워드 사용</a>
                            </li>
                            <li>
                                <a href="accesscontrol.html">클래스의 멤버 접근 제어</a>
                            </li>
                            <li>
                                <a href="classvars.html">클래스 멤버 이해하기</a>
                            </li>
                            <li>
                                <a href="initial.html">필드 초기화</a>
                            </li>
                            <li>
                                <a href="summaryclasses.html">클래스와 객체의 생성과 사용에 대한 요약</a>
                            </li>
                        </ul>
                        <li>
                            <a href="nested.html">중첩 클래스</a>
                        </li>
                        <ul>
                            <li>
                                <a href="innerclasses.html">내부 클래스 예제</a>
                            </li>
                            <li>
                                <a href="localclasses.html">지역 클래스</a>
                            </li>
                            <li>
                                <a href="anonymousclasses.html">무명 클래스</a>
                            </li>
                            <li>
                                <a href="lambdaexpressions.html">람다 표현식</a>
                            </li>
                            <ul>

                                <li>
                                    <a href="methodreferences.html">메소드 참조</a>
                                </li>
                            </ul>
                            <li>
                                <a href="whentouse.html">중첩 클래스, 지역 클래스, 무명 클래스, 람다 표현식을 사용할 때</a>
                            </li>
                        </ul>
                        <li>
                            <a href="enum.html">Enum Types</a>
                        </li>

                    </ul>

                </ul>
            </div>
        </div>
        <div class="col-sm-8">
        <!-- 2열 시작 -->
<h1>람다 표현식</h1>
<p>무명 클래스를 사용에 하나의 이슈가 있다.
단 하나의 메소드만 가지고 있는 인터페이스 같은 것을 
구현하는 무명 클래스는 간단하지만, 문법은 복잡하고 불편하다.
이런 경우에 다른 메소드에 인자로 기능을 전달 하고 싶을 것이다.
예를 들어 버튼을 클릭하면 어떤 일이 발생하는 기능 같은 것들을 생각해볼 수 있다.
람다 표현식은 이 것을 가능하게 하게 메소드의 인자나 데이터 코드로 
기능을 사용할 수 있게 한다.
</p>
<p>
이 전 섹션은 이름 없이 클래스를 구현하는 방법을 보여줬다.
이 것은 이름이 있는 클래스보단 간결 하기도 하지만,
메소드가 하나인 클래스는 무명클래스가 더 복잡하고 불편해보이기도 한다.
람다 표현식은 메소드가 하나인 클래스를 더욱 효과적으로 표현할 수 있게 해준다.
</p>
<p>이 섹션은 아래 내용을 다루고 있다.</p>
<ul>
    <li>람다 표현식의 이상적인 사용법
        <ul>
            <li>Approach 1: Create Methods That Search for Memebers That Match One Characteristic</li>
            <li>Approach 2: Create More Generalized Search Methods</li>
            <li>Approach 3: Specify Search Criteria Code in a Local Class</li>
            <li>Approach 4: Specify Search Criteria Code in an Anonymous Class</li>
            <li>Approach 5: Specify Search Criteria Code with a Lambda Expression</li>
            <li>Approach 6: Use Standard Functional Interfaces with Lambda Expressions</li>
            <li>Approach 7: Use Lambda Expressions Throughout Your Application</li>
            <li>Approach 8: Use Generics More Extensively</li>
            <li>Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters</li>
        </ul>
    </li>
    <li>GUI 프로그램의 람다 표현식</li>
    <li>람다 표현식의 문법</li>
    <li>감싸고 있는 scope의 지역 변수 접근</li>
    <li>Target Typing
        <ul>
            <li>Target Types and Method Arguments</li>
        </ul>
    </li>
    <li>Serialization</li>
</ul>
<h2>람다 표현식의 이상적인 사용법</h2>
<p>
소셜 네트워킹 프로그램을 만들고 있다고 가정하자. 
프로그램을 사용하는 멤버들 중 어떤 조건을 만족하는 멤버에게
메세지를 보내는 관리자의 기능을 구현하길 원한다고 가정하자.
아래 테이블은 자세한 use case를 작성한 것이다.
</p>

<table class="table">
    <tr>
        <th>Field</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Name</td>
        <td>Perform action on selected members</td>
    </tr>
    <tr>
        <td>Primary Actor</td>
        <td>관리자</td>
    </tr>
    <tr>
        <td>Preconditions</td>
        <td>관리자가 시스템에 로그인되어 있어야 한다.</td>
    </tr>
    <tr>
        <td>Postconditions</td>
        <td>특정 조건에 만족하는 멤버에게만 기능한다.</td>
    </tr>
    <tr>
        <td>Main Success Scenario</td>
        <td>
            <ol>
                <li>
                    관리자는 기능의 대상이 되는 멤버의 조건을 만든다.
                </li>
                <li>
                    선택한 조건의 멤버에게 할 기능을 명시한다.
                </li>
                <li>
                    <strong>Submit</strong>버튼을 선택한다.
                </li>
                <li>
                    시스템은 조건을 만족하는 모든 멤버를 찾는다.
                </li>
                <li>
                    시스템은 그 멤버에게 명시된 기능을 수행한다.
                </li>
            </ol>
        </td>
    </tr>
    <tr>
        <td>Extensions</td>
        <td>
            1a. 기능을 명시하기 전이나 <strong>Submit</strong>
            버튼을 선택하기 전에 관리자는 조건을 만족한 멤버를 미리 볼 수 있다.
        </td>
    </tr>
    <tr>
        <td>발생 주기</td>
        <td>하루에 여러번</td>
    </tr>
</table>
<p>
    소셜 네트워크 프로그램 멤버를 아래 <code>Person</code> 클래스로 표현했다.
</p>

<pre>
public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }

    public void printPerson() {
        // ...
    }
}</pre>
<p>
이 프로그램의 멤버가 <code>List&lt;Person&gt;</code> 객체에 저장되어 있다고 가정하자.
</p>
<p>
    이 섹션은 이 use case의 초보적인 접근으로 시작한다.
    지역 클래스와 무명 클래스를 거쳐 마지막에 효과적인 람다 표현식으로 접근한다.
    예제 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/RosterTest.java"><code>RosterTest</code></a> 프로그램의
    발췌를 찾아보라.
</p>

<h3>Approach 1: Create Methods That Search for Members That Match One Characteristic</h3>
<p>
    간단한 접근은 여러 메소드를 만드는 것이다. 각 메소드는 성별이나 나이 같은 하나의 조건에 매치되는 멤버를 찾는다.
    아래 메소드는 특정 나이보다 많은 멤버를 출력한다.
    
</p>

<pre>
public static void printPersonsOlderThan(List&lt;Person&gt; roster, int age) {
    for (Person p : roster) {
        if (p.getAge() >= age) {
            p.printPerson();
        }
    }
}</pre>
<p><strong>
    Note :
</strong>
    <code>List</code>는 차례가 있는 <code>Collection</code>이다. 
    <em>collection</em>은 한 곳에 여러 요소를 담은 객체이다.
    콜렉션은 데이터를 저장하고, 꺼내고, 조작하고, 종합할 때 사용한다.
    더 많은 정보는 <a href="https://docs.oracle.com/javase/tutorial/collections/index.html">Collections</a>
    섹션을 보기 바란다.
</p>

<p>
    이 접근은 프로그램을 변경에 취약하게 만든다. 
    새로운 데이터 타입 같은 것이 업데이트 되면 바로 작동되지 않는다.
    <code>Person</code>의 데이터의 구조가 변경되고 프로그램에
    업데이트 되어야 한다고 가정하자. 예를 들어, <code>Person</code>이 
    다른 자료형과 알고리즘으로 구성된 클래스 기록과
    다르게 측정된 나이 같은 다른 멤버 변수를 갖는다면 
    이 변경을 위해 프로그램의 많은 부분을 고쳐야 한다. 
    그리고 이 접근은 불필요하고 제한적이다. 만약
    어떤 나이보다 적은 멤버를 출력한다면 어떡해야 하는가?
</p>


<h3>Approach 2: Create More Generalized Search Methods</h3>

<p>
    아래 더 일반적인 접근의 <code>printPersonsOlderThan</code> 메소드이다.
    이 메소드는 특정 범위내의 나이인 멤버를 출력한다.

</p>

<pre>
public static void printPersonsWithinAgeRange(
    List&lt;Person&gt; roster, int low, int high) {
    for (Person p : roster) {
        if (low <= p.getAge() && p.getAge() < high) {
            p.printPerson();
        }
    }
}</pre>


<p>
    만약 특정 성별의 멤버를 출력해야 한다면, 또는 
    성별과 나이를 조합한 조건의 멤버를 출력해야 한다면?
    만약 <code>Person</code> 클래스를 변경해야 하고
    관계나 위치 정보같은 다른 속성을 추가 해야 한다면?
    이 메소드는 <code>printPersonsOlderThan</code>보다 
    일반적인 접근이지만 각 가능한 검색 질의에 대해
    메소드를 분리했다면 변경에 취약한 코드가 된다.
    찾는 조건을 명시하는 코드를 다른 클래스로
    분리할 수 있을 것이다.
</p>

<h3>
    Approach 3: Specify Search Criteria Code in a Local Class
</h3>

<p>
    아래 메소드는 명시한 검색 조건에 맞는 멤버를 출력한다.
</p>

<pre>
public static void printPersons(
    List&lt;Person&gt; roster, CheckPerson tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}</pre>

<p>
이 메소드는 <code>CheckPerson</code> 매개변수
<code>tester</code>의 <code>tester.test</code> 메소드를 호출해서
<code>List</code>매개변수 <code>roster</code>에 
있는 각 <code>Person</code> 객체를 검색 조건에 맞는지 체크한다.
</p>
<p>
    검색 조건을 명시하기 위해서 <code>CheckPerson</code>인터페이스를 구현해야 한다.
</p>
<pre>
interface CheckPerson {
    boolean test(Person p);
}</pre>

<p>
아래 클래스는 <code>test</code>메소드를 정의하면서 <code>CheckPerson</code> 인터페이스를 구현하였다.
이 메소드는 미국의 의무병역에 적합한 멤버를 찾는다. 만약 <code>Person</code> 매개변수가
남자이고 18~25세이면 <code>true</code>를 리턴한다.
</p>

<pre>
class CheckPersonEligibleForSelectiveService implements CheckPerson {
    public boolean test(Person p) {
        return p.gender == Person.Sex.MALE &&
            p.getAge() >= 18 &&
            p.getAge() <= 25;
    }
}</pre>

<p>
    이 클래스를 사용하기 위해 새 객체를 만들어서 <code>printPersons</code>를
    호출한다.
</p>

<pre>
printPersons(roster, new CheckPersonEligibleForSelectiveService());</pre>

<p>
이 접근은 이 전 접근보다 낫지만(<code>Person</code>의 구조를 바꾸어도
메소드를 다시 작성하지 않아도 된다.) 여전히 부가적인 코드를 작성해야한다.
즉 새 인터페이스와 각 검색을 위한 지역 클래스가 있어야 한다.
<code>CheckPersonEligibleForSelectiveService</code>가 인터페이스를 구현하기 때문에,
지역 클래스 대신 각 검색 마다 새 클래스를 선언해서 넘기는 무명 클래스를 사용할 수 있다.
</p>

<h3>Approach 4: Specify Search Criteria Code in an Anonymous Class</h3>
<p>
아래 <code>printPersons</code> 메소드 호출에서
인자 중에 하나는 미국 의무 병역에 적합한(남자이고 18~25세) 멤버를 필터하는 무명 클래스이다.
</p>
<pre>
printPersons(
    roster,
    new CheckPerson() {
        public boolean test(Person p) {
            return p.getGender() == Person.Sex.MALE
                && p.getAge() >= 18
                && p.getAge() <= 25;
        }
    }
);</pre>

<p>
    이 접근은 각 검색 조건마다 새로운 클래스를 만들지 않아도 되기 때문에 코드 양을 줄일 수 있다.
    그러나 무명 클래스 문법은 하나의 메소드만 있는 <code>CheckPerson</code>에 비해 비대하다.
    이런 경우 무명 클래스 대신 람다 표현식을 사용할 수 있다. 다음 섹션에서 살펴보자.
</p>

<h3>Approach 5: Specify Search Criteria Code with a Lambda Expression</h3>
<p>
<code>CheckPerson</code> 인터페이스는 <em>functional interface</em>이다. 
functional interface는 단 하나의 추상 메소드만 있는 인터페이스이다. 
(functional interface는 하나 이상의 default methods와 static methods를 가질 수 있다.)
functional interface는 단하나의 추상 메소드만 가지고 있기 때문에, 구현할 때
그 메소드의 이름을 생략할 수 있다. 그래서 무명 클래스 표현식 대신에 <em>람다 표현식</em>을 사용할 수 있는 것이다.
아래 메소드 호출에서 굵게 표시된 부분이다.
</p>
<pre>
printPersons(
    roster,
    <strong>(Person p) -&gt; p.getGender() == Person.Sex.MALE
        && p.getAge() &gt;= 18
        && p.getAge() &lt;= 25</strong>
);</pre>
<p>
<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax">Syntax of Lambda Expressions</a>에
람다 표현식 작성법에 대한 정보가 있다.
</p>
<p>
<code>CheckPerson</code>인터페이스 대신에 필요한 코드 양을 더 줄이는
standard functional interface를 사용할 수 있다.
</p>

<h3>Approach 6: Use Standard Functional Interfaces with Lambda Expressions</h3>
<p>
    <code>CheckPerson</code>인터페이스를 다시 보자.
</p>

<pre>
interface CheckPerson {
    boolean test(Person p);
}</pre>

<p>
    아주 간단한 인터페이스이다. 단 하나의 추상 메소드만 가지고 있으므로 functional interface이다.
    이 메소드는 하나의 파라미터를 가지고 있으며 <code>boolean</code>값을 리턴한다. 
    이 메소드는 너무 간단해서 프로그램에 정의하지 않아도 될 정도이다. 
    결과적으로 JDK는 <code>java.util.function</code>에 몇 가지 standard functional interface를 정의 한다.
</p>

<p>
    예를 들어, <code>CheckPerson</code> 인터페이스 대신에
     <code>Predicate&lt;T&gt;</code> 인터페이스를 사용할 수 있다.
     이 인터페이스는 <code>test(T t)</code>메소드를 가지고 있다.
</p>

<pre>
interface Predicate&lt;T&gt; {
    boolean test(T t);
}</pre>

<p>
<code>Predicate&lt;T&gt;</code>인터페이스는 generic interface의 예제이다. 
(generic interface에 관한 자세한 정보는 <a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Generics (Updated)</a>를
보라.) 제네릭 타입(generic interface 같은)은 angle brackets(&lt;&gt;)안에 한 개이상의
파라미터를 명시한다. 이 인터페이스는 단 하나의 타입 파라미터 <code>T</code>를 가지고 있다. 
실제 타입 인자를 넣어 제네릭 타입을 선언하거나 인스턴스화 하면, 당신은
parameterized type를 갖게 된다. 예를 들어 parameterized type <code>Predicate&lt;Person&gt;</code>는
아래와 같다.
</p>

<pre>
interface Predicate&lt;Person&gt; {
    boolean test(Person t);
}</pre>

<p>
    이 parameterized type은 <code>CheckPerson.boolean test(Person p)</code>와 같은
    리턴 타입과 파라미터가 있는 메소드가 있다. 결과적으로 아래 작성한 것 처럼 <code>CheckPerson</code>을
    <code>Predicate&lt;T&gt;</code>로 바꿀 수 있다.
</p>


<pre>
public static void printPersonsWithPredicate(
    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}</pre>

<p>
결국 아래 메소드 호출은 Approach 3에서 호출한 <code>printPersons</code>과 같게 된 것이다.
남자이고 18~25세인 조건으로 멤버를 찾는 동일한 결과이다.
</p>

<pre>
printPersonsWithPredicate(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);</pre>

<p>
    람다 표현식을 사용하는 것이 이 방법으로만 가능한 것은 아니다. 다음 접근에서
    람다 표현식을 사용하는 다른 방법을 보여주고 있다.
</p>

<h3>Approach 7: Use Lambda Expressions Throughout Your Application</h3>
<p>
람다 표현식을 사용할 수 있는 <code>printPersonsWithPredicate</code>메소드를 다시 살펴보자.

</p>

<pre>
public static void printPersonsWithPredicate(
    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}</pre>

<p>
    이 메소드는 <code>List</code>타입의 <code>roster</code> 파라미터에 담긴 각 <code>Person</code>
    객체를 <code>Predicate</code>타입의 <code>tester</code> 파라미터로 조건을 만족하는지 체크 한다.
    만약 <code>Person</code>객체가 <code>tester</code>조건을 만족하면 <code>Person</code>
    객체의 <code>printPerson</code>메소드를
    호출한다.

</p>

<p>
<code>printPerson</code>메소드를 호출하는 대신, <code>tester</code>의 조건을 만족하는
<code>Person</code>객체에 다른 액션을 작성할 수 있다. 
이 액션을 람다 표현식으로 작성할 수 있다. 하나의 인자 (<code>Person</code> 객체)를 받고
void를 리턴하는 <code>printPerson</code>메소드 같은 람다 표현식을 원한다고 가정하자.
람다 표현식을 사용하기 위해서 functional interface가 필요하다는 것을 기억하자. 
이 경우 <code>Person</code>타입의 인자 하나를 받고 void를 리턴하는 추상 메소드가 있는
functional interface가 필요하다. <code>Consumer&lt;T&gt;</code> 인터페이스는 
이런 특징을 가진 <code>void accept(T t)</code> 메소드를 가지고 있다.
아래 메소드는 <code>p.printPerson()</code> 호출을 <code>Consumer&lt;Person&gt;</code> 객체의
<code>accept</code>메소드로
바꾼 예제를 보여주고 있다.
</p>

<pre>
public static void processPersons(
    List&lt;Person&gt; roster,
    Predicate&lt;Person&gt; tester,
    <strong>Consumer&lt;Person&gt; block</strong>) {
        for (Person p : roster) {
            if (tester.test(p)) {
                <strong>block.accept(p);</strong>
            }
        }
}</pre>

<p>
그 결과 아래 메소드 호출은 남자이고 18~25세의 멤버를
필터하는 Approach 3에서 호출한 <code>printPersons</code>와
같은 것이 되었다. 멤버를 출력하는 람다 표현식은 굵게 표시되었다.
</p>

<pre>
processPersons(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.printPerson()
);</pre>

<p>
만약 멤버의 프로필을 출력하는 대신 다른 것을 더 원할 수도 있다.
멤버의 프로필이 유효한지 확인하거나 연락처를 받길 원한다고 가정해보자.
이 경우 리턴 값을 갖는 추상 메소드가 있는 functional interface가 필요하다.
<code>Function&lt;T,R&gt;</code> 인터페이스는 <code>R apply(T t)</code>메소드를
가지고 있다. 아래 메소드는 <code>mapper</code> 파라미터로 명시된 데이터를 받고
<code>block</code> 파라미터에 명시된 액션을 실행한다.
</p>

<pre>
public static void processPersonsWithFunction(
    List&lt;Person&gt; roster,
    Predicate&lt;Person&gt; tester,
    Function&lt;Person, String&gt; mapper,
    Consumer&lt;String&gt; block) {
    for (Person p : roster) {
        if (tester.test(p)) {
            String data = mapper.apply(p);
            block.accept(data);
        }
    }
}</pre>

<p>
    아래 메소드 호출은 <code>roster</code>중 남자이고 18~25세인 멤버를 필터하고 
    이메일을 꺼내서 출력하는 메소드 호출이다.
</p>
<pre>
processPersonsWithFunction(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);</pre>
<h3>Approach 8: Use Generics More Extensively</h3>
<p>
<code>processPersonsWithFunction</code> 메소드를 다시 살펴보자.
아래 코드는 모든 데이터 타입을 요소로 같는 콜렉션을 처리하는 (파라미터로 받는) 제네릭 버전이다.
</p>
<pre>
public static &lt;X, Y&gt; void processElements(
    Iterable&lt;X&gt; source,
    Predicate&lt;X&gt; tester,
    Function &lt;X, Y&gt; mapper,
    Consumer&lt;Y&gt; block) {
    for (X p : source) {
        if (tester.test(p)) {
            Y data = mapper.apply(p);
            block.accept(data);
        }
    }
}</pre>

<p>
조건에 적합한 멤버의    e-mail 주소를 출력하기 위해
<code>processElements</code>메소드를 아래와 같이 호출하였다.
</p>

<pre>
processElements(
    roster,
    p -&#x3E; p.getGender() == Person.Sex.MALE
        &#x26;&#x26; p.getAge() &#x3E;= 18
        &#x26;&#x26; p.getAge() &#x3C;= 25,
    p -&#x3E; p.getEmailAddress(),
    email -&#x3E; System.out.println(email)
);</pre>

<p>
이 메소드 호출은 아래 기능을 수행한다. 
</p>

<ol>
    <li>
콜렉션 <code>source</code>에서 원본 객체들을 얻는다.
이 예제에서는 콜렉션 <code>roster</code>에서 <code>Person</code>
객체 원본을 얻는다. <code>roster</code>는 <code>List</code>
타입이며, 곧 <code>Iterable</code>타입이다.
</li>
    <li>
<code>Predicate</code> <code>tester</code> 객체에
매치되는 객체를 필터한다. 이 예제에서
<code>Predicate</code> 객체는 Selective Service에 적합한
멤버를 명시한 람다 표현식이다.
    </li>
    <li>
필터된 각 객체를 <code>Function</code> <code>mapper</code>
객체에 명시된 값으로 매핑한다. 이 예제에서 
<code>Function</code> 객체는 멤버의 이메일 주소를 반환하는
람다 표현식이다.
    </li>
    <li>
매핑된 각 객체에 <code>Consumer</code> <code>block</code>
객체에 명시된 기능을 수행한다. 이 예제에서 <code>Consumer</code>
객체는 <code>Function</code> 객체에서
반환받은 이메일 주소 문자열을 출력하는 람다 표현식이다. 
    </li>
</ol>
<p>
이런 기능을 집합 연산자로 교체할 수 있다.
</p>


<h3>Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters</h3>
<p>
아래 예제는
<code>roster</code> 콜렉션에 담겨있는 멤버중 
Selective Service 적합한 멤버의 이메일 주소를
출력하기위해 집합 연산을 사용하고 있다.
</p>
<pre>
roster
.stream()
.filter(
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25)
.map(p -> p.getEmailAddress())
.forEach(email -> System.out.println(email));</pre>
<p>
아래 테이블은 <code>processElements</code> 메소드의 기능에
해당하는 집합 연산을 매핑해서 보여주고 있다.
</p>

<table class="table">
    <tr>
      <th><code>processElements</code> Action</th>
      <th>Aggregate Operation</th>
    </tr>
    
    <tr>
      <td>Obtain a source of objects</td>
      
      <td><code>Stream&lt;E&gt; <strong>stream</strong>()</code></td>
    </tr>
    
    <tr>
      <td>Filter objects that match a <code>Predicate</code> object</td>
      <td><code>Stream&lt;T&gt; <strong>filter</strong>(Predicate&lt;? super T&gt; predicate)</code></td>
    </tr>
    
    <tr>
    
      <td>Map objects to another value as specified by a <code>Function</code> object</td>
      
      <td><code>&lt;R&gt; Stream&lt;R&gt; <strong>map</strong>(Function&lt;? super T,? extends R&gt; mapper)</code></td>
      
    </tr>
    
    <tr>
      <td>Perform an action as specified by a <code>Consumer</code> object</td>
      <td><code>void <strong>forEach</strong>(Consumer&lt;? super T&gt; action)</code></td>
    </tr>
    
</table>
<p>
<code>filter</code>, <code>map</code>,
<code>forEach</code> 연산은 <em>집합 연산</em>이다.
집합 연산은 콜렉션에서 직접처리하지 않고 스트림에서 요소들을 처리한다.
그래서 이 예제에서 가장 먼저 호출한 메소드가 <code>stream</code>이다.
<em>스트림 stream</em>은 요소의 순차적 배열이다.
콜렉션과 다르게 요소들을 저장하는 자료구조가 아니다.
대신 스트림은 콜렉션 같은 원본에서 값들을 파이프라인을
통해서 옮겨간다. <em>파이프라인 pipeline</em>은
스트림의 순차적 연산이다. 이 예제에서는 <code>filter-map-forEach</code>이다.
그리고 집합 연산은 어떻게 기능해야 하는 지 직접
작성할 수 있게 보통 람다 표현식을 파라미터로 받는다.
</p>
<p>
집합 연산의 더 많은 정보는 
<a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html">Aggregate Operations</a>를
보기 바란다.
</p>

<h2>GUI 프로그램의 람다 표현식</h2>
<p>
GUI 프로그램에서 키보드 입력이나 마우스 입력같은 이벤트를 처리하기 위해
보통 특정 인터페이스를 구현한 이벤트 핸들러를 만들게 된다.
종종 이벤트 핸들러 인터페이스는 하나의 메소드만 있는 functional interface이다.
</p>

<p>
JavaFX 예제 <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm">HelloWorld.java</a>
에서 무명 클래스를 람다 표현식으로 교체할 수 있다.
</p>

<pre>
btn.setOnAction(<b>new EventHandler&lt;ActionEvent&gt;() {</b>

    <b>@Override</b>
    <b>public void handle(ActionEvent event) {</b>
        <b>System.out.println("Hello World!");</b>
    <b>}</b>
<b>}</b>);</pre>

<p>
<code>btn.setOnAction</code> 메소드 호출은
<code>btn</code>객체로 표현된 버튼을 선택했을 때
일어나야 하는 일을 명시한 것이다.
이 메소드는 <code>EventHandler&lt;ActionEvent&gt;</code>타입의
객체를 요구한다.
<code>EventHandler&lt;ActionEvent&gt;</code>인터페이스는
<code>void handle(T event)</code>메소드 하나만 가지고 있다.
이 인터페이스는 functional interface이기 때문에,
아래 처럼 람다 표현식으로 바꿀 수 있다.
</p>

<pre>        
btn.setOnAction(
    <b>event -&gt; System.out.println("Hello World!")</b>
);</pre>

<h2>람다 표현식의 문법</h2>
<p>람다 표현식은 아래 구성요소로 이루어져있다.</p>
<ul>
    <li>
        <p>
()괄호안에 파라미터 형식의 콤마로 구분된 리스트.
<code>CheckPerson.test</code> 메소드는 
<code>Person</code>객체의 <code>p</code>
파라미터 하나만 가지고 있다.
</p>
<p>
    <strong>Note : </strong> 람다 표현식의 파라미터의
    타입을 생략할 수 있다. 그리고 파라미터가 하나만 있다면
    ()괄호를 생략할 수 있다. 예를 들어 아래 람다 표현식은
    문법에 맞는 형식이다:
</p>
<pre>
p -&gt; p.getGender() == Person.Sex.MALE
    && p.getAge() &gt;= 18
    && p.getAge() &lt;= 25
</pre>
    </li>
<li>
<p><code>-&gt;</code> 화살표 기호</p>
</li>
    <li>
<p>몸체 : 단순한 식이나 코드 블럭. 이 예제는 아래 식을
    사용하고 있다.
</p>
<pre>
p -&gt; p.getGender() == Person.Sex.MALE
    && p.getAge() &gt;= 18
    && p.getAge() &lt;= 25
</pre>
<p>
만약 단순한 하나의 식이면 Java는 식을 계산한 결과값을
반환한다. 대신 <code>return</code>문을 사용할 수 있다.
</p>
<pre>
p -&gt; {
    return p.getGender() == Person.Sex.MALE
        && p.getAge() &gt;= 18
        && p.getAge() &lt;= 25    
}</pre>
<p>
<code>return</code>문은 람다 표현식에서 어떤 계산식이 아니다.
꼭 {}를 사용해야 한다. 그러나 void 메소드 호출은 {}로 감쌀 필요는
없다. 예를 들어 아래 코드는 문법에 맞는 람다 표현식이다.
</p>
<pre>email -&gt; System.out.println(email)</pre>


    </li>
</ul>
<p>
람다 표현식은 메소드 선언과 비슷하다는 것을 주목해라;
람다 표현식을 무명 메소드 처럼 생각할 수 있다.
</p>
<p>
아래 예제 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Calculator.java"><code>Calculator</code></a>는
하나 이상의 파라미터 형식에 사용한 람다 표현식이다.
</p>

<pre>

public class Calculator {
    
    interface IntegerMath {
        int operation(int a, int b);   
    }
    
    public int operateBinary(int a, int b, IntegerMath op) {
        return op.operation(a, b);
    }
    
    public static void main(String... args) {
    
        Calculator myApp = new Calculator();
        IntegerMath addition = (a, b) -&gt; a + b;
        IntegerMath subtraction = (a, b) -&gt; a - b;
        System.out.println(&quot;40 + 2 = &quot; +
            myApp.operateBinary(40, 2, addition));
        System.out.println(&quot;20 - 10 = &quot; +
            myApp.operateBinary(20, 10, subtraction));    
    }
}

</pre>

<p>
<code>operateBinary</code> 메소드는 
두 정수의 수학 연산을 한다. 이 연산은 <code>IntegerMath</code>의
객체로 명시한다. 위 예제는 두 연산을 람다 표현식 
<code>addition</code>과 <code>subtraction</code>으로 정의했다.
아래 처럼 결과가 나온다.
</p>
<pre class="codeblock">40 + 2 = 42
20 - 10 = 10</pre>

<h2>감싸고 있는 scope의 지역 변수 접근</h2>
<p>
지역 클래스와 무명 클래스 처럼, 람다 표현식도 capture variable할 수 있다.
즉 감싸고 있는 scope의 지역변수에 접근할 수 있다.
그러나 지역 클래스, 무명 클래스와 다르게
람다 표현식은 shadowing 이슈가 없다. 람다 표현식은 lexically scope이다.
다시 말하면 슈퍼타입으로 부터 어떤 이름도 상속 받지 않고
새로운 단계의 scope을 만들지 않는다는 뜻이다. 
람다 표현식 내의 선언은 감싼 scope의 구성 요소 자체로 해석된다.
아래 예제 <code>LambdaScopeTest</code>에서
시연해보고 있다.

</p>
<pre>

import java.util.function.Consumer;

public class LambdaScopeTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            
            // The following statement causes the compiler to generate
            // the error &quot;local variables referenced from a lambda expression
            // must be final or effectively final&quot; in statement A:
            //
            // x = 99;
            
            Consumer&lt;Integer&gt; myConsumer = (y) -&gt; 
            {
                System.out.println(&quot;x = &quot; + x); // Statement A
                System.out.println(&quot;y = &quot; + y);
                System.out.println(&quot;this.x = &quot; + this.x);
                System.out.println(&quot;LambdaScopeTest.this.x = &quot; +
                    LambdaScopeTest.this.x);
            };

            myConsumer.accept(x);

        }
    }

    public static void main(String... args) {
        LambdaScopeTest st = new LambdaScopeTest();
        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}
</pre>
<p>이 예제는 아래 결과를 출력한다.</p>

<pre>
x = 23
y = 23
this.x = 1
LambdaScopeTest.this.x = 0
</pre>
<p>
만약 <code>myConsumer</code> 람다 표현식의 선언에서 파라미터 x를 y로 바꾸면
컴파일러는 에러를 출력한다.
</p>
<pre>Consumer&lt;Integer&gt; myConsumer = (x) -> {
    // ...
}</pre>
<p>
컴파일러는 "variable x is already defined in method methodInFirstLevel(int)"
라는 에러를 출력한다. 람다 표현식은 새로운 단계의 scope을 만들지 않기 때문이다.
그 결과 감싸고 있는 scope의 필드와 메소드 지역 변수를 직접 접근 할 수 있다.
예를 들어, 람다 표현식은 <code>methodInFirstLevel</code>메소드의 파라미터
<code>x</code>에 직접 접근한다.
감싼 클래스의 변수에 접근하기 위해 <code>this</code>키워드를 사용한다.
이 예제에서, <code>this.x</code>는 <code>FirstLevel.x</code> 멤버 변수를 가리킨다.

</p>
<p>
그러나 지역 클래스나 무명 클래스처럼, 람다 표현식은
감싸고 있는 블럭의 final이나 effectively final의 파라미터나
지역 변수만 접근 할 수 있다. 예를 들어 아래 할당 명령문을
<code>methodInFirstLevel</code> 선언 바로 다음에
추가한다고 가정해보자.
</p>
<pre class="codeblock">void methodInFirstLevel(int x) {
    <strong>x = 99;</strong>
    // ...
}</pre>

<p>
이 명령문 때문에 <code>FirstLevel.x</code>의 변수는
더이상 effectively final이 아니다.
그 결과 Java 컴파일러는 람다 표현식에서
<code>FirstLevel.x</code>를 접근하려는 코드에서
 에러 메세지 "local variables referenced from a lambda expression must be final or effectively final"를 출력한다.

</p>
<pre>System.out.println("x = " + x);</pre>

<h2>Target Typing</h2>
<p>
    람다 표현식의 자료형을 어떻게 결정할 수 있을까?
남자이고 나이가 18~25세인 멤버를 선택하는 람다 표현식을
기억해보자:
</p>
<pre class="codeblock">p -&gt; p.getGender() == Person.Sex.MALE
    &amp;&amp; p.getAge() &gt;= 18
    &amp;&amp; p.getAge() &lt;= 25</pre>

<p>
이 람다 표현식은 아래 두 메소드에서 사용된다.
</p>

<ul>
    <li>Approach 3: Specify Search Criteria Code in a Local Class 에서
            <code>public static void printPersons(List&lt;Person&gt; roster, CheckPerson tester)</code>
    </li>
    <li>
            Approach 6: Use Standard Functional Interfaces with Lambda Expressions 에서    <code>public void printPersonsWithPredicate(List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</code>
    </li>
</ul>
<p>
Java 런타임이 <code>printPersons</code> 메소드를 호출할 때,
<code>CheckPerson</code> 타입을 기대하게 되므로
람다 표현식은 그 타입이다.
그러나 Java 런타임이 <code>printPersonsWithPredicate</code> 메소드를
호출할 때 <code>Predicate&lt;Person&gt;</code> 타입을 기대하게
되므로 람다 표현식은 이 타입이된다.
이 메소드들이 기대하는 자료형이 <em>목적 target type</em>이라고 한다.
람다 표현식의 타입을 결정하기 위해 Java 컴파일러는 람다 표현식이
발견된 context나 상황의 target type을 사용한다. 
Java 컴파일러가 target type을 결정할 수 있는
상황에서만 람다 표현식을 사용할 수 있다. 그 상황이 아래 나열되어 있다.
</p>

<ul>
    <li>
        <p>변수 선언 Variable declarations</p>
    </li>
    <li>
        <p>할당 Assignments</p>
    </li>
    <li>
        <p>Return statements</p>
    </li>
    <li>
        <p>배열 초기화 Array initializers</p>
    </li>
    <li>
        <p>메소드나 생성자 인자 Method or constructor arguments</p>
    </li>
    <li>
        <p>람다 표현식 몸체 Lambda expression bodies</p>
    </li>
    <li>
        <p>Conditional expressions, ? :</p>
    </li>
    <li>
        <p>형변환 Cast expressions</p>
    </li>
</ul>
<h3>Target Types and Method Arguments</h3>
<p>
    메소드 인자에서 Java 컴파일러는 target type을 두 기능 (오버로드와 
    타입 추론)으로 결정한다. 
</p>
<p>아래 두 functional interface를 살펴보자 (
        <a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html"><code>java.lang.Runnable</code></a> 과
        <a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html"><code>java.util.concurrent.Callable&lt;V&gt;</code></a>):</p>

<pre class="codeblock">public interface Runnable {
    void run();
}

public interface Callable&lt;V&gt; {
    V call();
}</pre>

<p>
<code>Runnable.run</code> 은 값을 반환하지 않고, 
<code>Callable&lt;V&gt;</code>는 반환한다.
</p>

<p>
아래 <code>invoke</code> 메소드를 오버로드 했다고 
가정하자.
</p>

<pre class="codeblock">void invoke(Runnable r) {
    r.run();
}

&lt;T&gt; T invoke(Callable&lt;T&gt; c) {
    return c.call();
}</pre>

<p>아래 코드는 어떤 메소드를 호출하는가?</p>


<pre class="codeblock">String s = invoke(() -&gt; "done");</pre>
<p>
값을 리턴하는 <code>invoke(Callable&lt;T&gt;</code> 메소드가 호출될 것이다.
이 경우 <code>() -&gt; "done"</code> 람다 표현식의 타입은 <code>Callable&lt;T&gt;</code> 이다.
</p>
<h2>Serialization</h2>
<p>
만약 target type과 captured arguments 가 
serializable 하다면 람다 표현식을 <a href="https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html">serialize</a>할 수 있다.
그러나 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#serialization">inner classes</a> 처럼
람다 표현식의 serialization 은 매우 권장되지 않는다.


</p>



        <!-- 2열 끝 -->
        </div>

        <!-- container 끝 -->
    </div>

</body>

</html>